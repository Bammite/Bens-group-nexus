<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Suivi de livraison en direct</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100vh; }

    /* Style pour le marqueur du livreur*/
    .livreur-marker {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23FF4136" width="36px" height="36px"><path d="M0 0h24v24H0z" fill="none"/><path d="M20 8h-3V4H3c-1.1 0-2 .9-2 2v11h2c0 1.66 1.34 3 3 3s3-1.34 3-3h6c0 1.66 1.34 3 3 3s3-1.34 3-3h2v-5l-3-4zM6 18.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm13.5-9l1.96 2.5H17V9.5h2.5zM18 18.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>');
      background-size: cover;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>

<div id="map"></div>

<script>
    // le jeton d'acc√®s Mapbox
    mapboxgl.accessToken = 'pk.eyJ1IjoibGVwcmluY2VuIiwiYSI6ImNtY2pkamJrMjAwYzAyaXI1emhtMDhhNWgifQ.GDkmYQLAB5p1WdfObsnVqA';

    // Coordonn√©es de d√©part (Dakar, Point E) et d'arriv√©e (Dakar, Plateau)
    const pointA = [-17.475, 14.703]; // Point E
    const pointB = [-17.442, 14.671]; // Plateau

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/streets-v12',
      center: pointA,
      zoom: 14
    });

    //  Fonction principale
    map.on('load', async () => {
      // 1. Obtenir l'itin√©raire complet via l'API Directions
      const routeGeoJSON = await getRoute(pointA, pointB);
      const routeCoordinates = routeGeoJSON.geometry.coordinates;

      // 2. Afficher l'itin√©raire complet en bleu
      map.addSource('route', {
        type: 'geojson',
        data: routeGeoJSON
      });
      map.addLayer({
        id: 'route',
        type: 'line',
        source: 'route',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#0074D9', 'line-width': 5, 'line-opacity': 0.7 }
      });

      // 3. Cr√©er une source pour le trajet d√©j√† effectu√© (initialement vide)
      map.addSource('trajet-effectue', {
        type: 'geojson',
        data: {
          type: 'Feature',
          geometry: { type: 'LineString', coordinates: [pointA] }
        }
      });
      map.addLayer({
        id: 'trajet-effectue',
        type: 'line',
        source: 'trajet-effectue',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#FF4136', 'line-width': 5 } // Rouge vif
      });

      // 4. Ajouter les marqueurs D√©part & Arriv√©e
      addMarkers(pointA, pointB);

      // 5. Ajuster la carte pour voir tout l'itin√©raire
      const bounds = new mapboxgl.LngLatBounds(pointA, pointB);
      map.fitBounds(bounds, { padding: 80 });
      
      // 6. D√©marrer la simulation du mouvement du livreur
      simulateDelivery(routeCoordinates);
    });
    
    // --- Fonctions utilitaires ---

    /**
     * R√©cup√®re l'itin√©raire depuis l'API Mapbox Directions
     */
    async function getRoute(start, end) {
      const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${start[0]},${start[1]};${end[0]},${end[1]}?geometries=geojson&access_token=${mapboxgl.accessToken}`;
      const response = await fetch(url);
      const data = await response.json();
      console.log(data);
      return {
        type: 'Feature',
        geometry: data.routes[0].geometry
      };
    }
    
    /**
     * Ajoute les marqueurs de d√©part, d'arriv√©e et du livreur
     */
    function addMarkers(start, end) {
      // Marqueur de d√©part
      new mapboxgl.Marker({ color: '#2ECC40', scale: 0.8 })
        .setLngLat(start)
        .setPopup(new mapboxgl.Popup().setHTML("<h4>Point de d√©part</h4>"))
        .addTo(map);

      // Marqueur d'arriv√©e
      new mapboxgl.Marker({ color: '#001f3f', scale: 0.8 })
        .setLngLat(end)
        .setPopup(new mapboxgl.Popup().setHTML("<h4>Destination</h4>"))
        .addTo(map);
    }
    
    /**
 * Simule le d√©placement fluide du livreur le long de l'itin√©raire.
 * @param {Array<Array<number>>} routeCoords - Les coordonn√©es de l'itin√©raire.
 */
function simulateDelivery(routeCoords) {
  // Cr√©e un marqueur HTML personnalis√© pour le livreur
  const livreurElement = document.createElement('div');
  livreurElement.className = 'livreur-marker';
  const livreurMarker = new mapboxgl.Marker(livreurElement)
    .setLngLat(routeCoords[0])
    .addTo(map);

  let startTime = 0;
  let progress = 0;
  // Index du segment de route actuel (entre le point 'i' et 'i+1')
  let currentSegmentIndex = 0; 
  
  // Calcule la distance totale de l'itin√©raire pour g√©rer une vitesse constante
  const totalDistance = calculateTotalDistance(routeCoords);
  const vitesseKmH = 50; // Vitesse de simulation en km/h
  const dureeAnimation = (totalDistance / (vitesseKmH / 3600)) * 1000; // Dur√©e totale en ms

  // La fonction d'animation principale
  function animate(timestamp) {
    if (!startTime) startTime = timestamp;
    const elapsedTime = timestamp - startTime;
    progress = elapsedTime / dureeAnimation;

    if (progress >= 1) {
      // Animation termin√©e
      livreurMarker.setLngLat(routeCoords[routeCoords.length - 1]);
      map.getSource('trajet-effectue').setData({
        type: 'Feature',
        geometry: { type: 'LineString', coordinates: routeCoords }
      });
      console.log("Livraison termin√©e ! üéâ");
      return;
    }

    // Trouve le point exact sur l'itin√©raire correspondant √† la progression
    const pointSurRoute = getPointAlongRoute(routeCoords, progress);
    
    // Met √† jour la position du marqueur et la vue de la carte
    livreurMarker.setLngLat(pointSurRoute.coords);
    map.panTo(pointSurRoute.coords);
    
    // Met √† jour la ligne du trajet effectu√©
    const trajetParcouru = routeCoords.slice(0, pointSurRoute.segmentIndex + 1);
    trajetParcouru.push(pointSurRoute.coords); // Ajoute la position actuelle
    map.getSource('trajet-effectue').setData({
        type: 'Feature',
        geometry: { type: 'LineString', coordinates: trajetParcouru }
    });

    // Demande √† continuer l'animation √† la prochaine frame
    requestAnimationFrame(animate);
  }

  // Lance l'animation
  requestAnimationFrame(animate);
}

// --- Fonctions utilitaires √† ajouter ---

/**
 * Calcule la distance euclidienne entre deux points (approximation)
 */
function getDistance(p1, p2) {
    const R = 6371; // Rayon de la Terre en km
    const dLat = (p2[1] - p1[1]) * Math.PI / 180;
    const dLon = (p2[0] - p1[0]) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(p1[1] * Math.PI / 180) * Math.cos(p2[1] * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c; // distance en km
}

/**
 * Calcule la distance totale d'un itin√©raire.
 */
function calculateTotalDistance(coords) {
    let totalDistance = 0;
    for (let i = 0; i < coords.length - 1; i++) {
        totalDistance += getDistance(coords[i], coords[i+1]);
    }
    return totalDistance;
}

/**
 * Trouve le point sur l'itin√©raire qui correspond √† un certain pourcentage de progression.
 */
function getPointAlongRoute(coords, progress) {
    const totalDist = calculateTotalDistance(coords);
    const targetDist = totalDist * progress;
    let distanceParcourue = 0;

    for (let i = 0; i < coords.length - 1; i++) {
        const p1 = coords[i];
        const p2 = coords[i+1];
        const segmentDist = getDistance(p1, p2);

        if (distanceParcourue + segmentDist >= targetDist) {
            const fractionSurSegment = (targetDist - distanceParcourue) / segmentDist;
            const lng = p1[0] + (p2[0] - p1[0]) * fractionSurSegment;
            const lat = p1[1] + (p2[1] - p1[1]) * fractionSurSegment;
            return { coords: [lng, lat], segmentIndex: i };
        }
        distanceParcourue += segmentDist;
    }

    return { coords: coords[coords.length - 1], segmentIndex: coords.length - 2 };
}

</script>
</body>
</html>

